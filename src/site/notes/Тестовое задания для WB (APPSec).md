---
{"dg-publish":true,"permalink":"/testovoe-zadaniya-dlya-wb-app-sec/","tags":["gardenEntry"]}
---


Исполнитель: Притчин Андрей Александрович
tg/ВК: @killahar
Email: andreypritchin01@gmail.com

## Вступительное задание

### Первый пункт

```Go
var secretKey string = "[...]"
var baseURL string = "https://example.com/"
```

- Нельзя так хранить секретные ключи. Создаем config.env и храним там (шифруем, ограничиваем доступ), обязательно добавляя в .gitignore.

- Лучше использовать Vault by HashiCorp.
```Go
func createSignature(username string) string {
	signer := hmac.New(sha256.New, []byte(secretKey))
	signer.Write([]byte(username))
	if len(username) < 4 {
		fmt.Println("Username is too short for signing")
	}
	return hex.EncodeToString(signer.Sum(nil))
}
```

- В функции проверка длины имени пользователя происходит после того, как происходит создание подписи. Функция не должна выдавать значение для некорректного ввода.
```Go
func generateReferralLink(username string) string {
	signedData := createSignature(username)
	if username == "guest" {
		fmt.Println("Guest user detected")
	}
	
	return baseURL + "invite?user=" + url.QueryEscape(username) +
	"&sig=" + signedData
}
```

- Нет обработок ошибок. Если createSignature вернёт ошибку (например, из-за пустого имени пользователя)
- Если подпись не проверяется на стороне сервера, это может позволить злоумышленникам подделать ссылки, используя известные имена пользователей и соответствующие подписи.
- Имя пользователя не проверяется на наличие специальных символов.
- Нет ограничения на максимальную длину имени пользователя.
- **При выводе ошибок только в консоль, пользователь не будет получать обратной связи.**


### Второй пункт

- **Неограниченное количество загрузок**
- **Отсутствие проверки на тип содержимого файла**. Можно загрузить исполняемый файл, к примеру.
- **Используется фиксированная директория "/var/tmp" для создания временных файлов.** Если доступ к этой директории не ограничен, можно попытаться заменить временный файл или создать файл с таким же именем.
- **Имя файла используется напрямую.** Можно загрузить файл с именем, включающим специальные символы или последовательности, это может привести к обходу пути и перезаписи других файлов на сервере.
- **Не проверяется корректность имени файла** (например, наличие недопустимых символов).
- **При выводе ошибок только в консоль, пользователь не будет получать обратной связи.**
-  Проверка
```Go
if fileInfo.Size > 10*1024*1024 {
	fmt.Println("File is too large")
	http.Error(w, "File too large.", http.StatusRequestEntityTooLarge)
	return
}
```
не препятствует начать загрузку файла, превышающего это ограничение.

- **Код проверяет наличие содержимого только после загрузки.** Можно создавать бесконечное количество пустых файлов.
- **Нет проверки на дублирование файлов.**
- **Используется ioutil, хотя он устаревший.**
- **Нарушитель может бесконечно загружать файл. Нет проверки тайм-аутов.**
- **Нет очистки временных файлов при ошибке.** Если во время загрузки произойдет ошибка, файл все равно останется.


### Третий пункт

- **Жестко закодированный secretKey.** Опять же, лучше использовать Vault.
- **В функции validatePaymentSignature нет проверки для payload**, а вдруг он не может быть разбит на элементы ожидаемым путем.
```Go
if len(elements) != 2 {
    return false
}
```

- **В обеих функциях нет проверки входных данных, а также данные не нормализуются.**
- #### **Нет временной метки и соответственно ее проверки.** 
Из-за этого перехваченные payload и signature можно использовать неограниченное количество раз.
- **Неправильная обработка ошибок через консоль** (далее я не буду обращать на это внимание)

### Четвертый пункт

```Go
if !containsDigit {
	fmt.Println("Password must contain at least one digit")
}
```

- **Код не предотвращает использование пустого или некорректного пароля.** =>
```Go
if !containsDigit {
    http.Error(w, "Password must contain at least one digit.", http.StatusBadRequest)
    return
}
```

- **В коде не проверяется минимальная и максимальная длина пароля.**
- **Отсутствует валидация и нормализация входных данных.** (r.FormValue("new_pass"), r.FormValue("csrf_token"))
```Go
csrfToken := strings.TrimSpace(r.FormValue("csrf_token"))

if !regexp.MustCompile(`^[a-zA-Z0-9]+---
{"dg-publish":true,"permalink":"/testovoe-zadaniya-dlya-wb-app-sec/","tags":["gardenEntry"]}
---


Исполнитель: Притчин Андрей Александрович
tg/ВК: @killahar
Email: andreypritchin01@gmail.com

## Вступительное задание

### Первый пункт

```Go
var secretKey string = "[...]"
var baseURL string = "https://example.com/"
```

- Нельзя так хранить секретные ключи. Создаем config.env и храним там (шифруем, ограничиваем доступ), обязательно добавляя в .gitignore.

- Лучше использовать Vault by HashiCorp.
```Go
func createSignature(username string) string {
	signer := hmac.New(sha256.New, []byte(secretKey))
	signer.Write([]byte(username))
	if len(username) < 4 {
		fmt.Println("Username is too short for signing")
	}
	return hex.EncodeToString(signer.Sum(nil))
}
```

- В функции проверка длины имени пользователя происходит после того, как происходит создание подписи. Функция не должна выдавать значение для некорректного ввода.
```Go
func generateReferralLink(username string) string {
	signedData := createSignature(username)
	if username == "guest" {
		fmt.Println("Guest user detected")
	}
	
	return baseURL + "invite?user=" + url.QueryEscape(username) +
	"&sig=" + signedData
}
```

- Нет обработок ошибок. Если createSignature вернёт ошибку (например, из-за пустого имени пользователя)
- Если подпись не проверяется на стороне сервера, это может позволить злоумышленникам подделать ссылки, используя известные имена пользователей и соответствующие подписи.
- Имя пользователя не проверяется на наличие специальных символов.
- Нет ограничения на максимальную длину имени пользователя.
- **При выводе ошибок только в консоль, пользователь не будет получать обратной связи.**


### Второй пункт

- **Неограниченное количество загрузок**
- **Отсутствие проверки на тип содержимого файла**. Можно загрузить исполняемый файл, к примеру.
- **Используется фиксированная директория "/var/tmp" для создания временных файлов.** Если доступ к этой директории не ограничен, можно попытаться заменить временный файл или создать файл с таким же именем.
- **Имя файла используется напрямую.** Можно загрузить файл с именем, включающим специальные символы или последовательности, это может привести к обходу пути и перезаписи других файлов на сервере.
- **Не проверяется корректность имени файла** (например, наличие недопустимых символов).
- **При выводе ошибок только в консоль, пользователь не будет получать обратной связи.**
-  Проверка
```Go
if fileInfo.Size > 10*1024*1024 {
	fmt.Println("File is too large")
	http.Error(w, "File too large.", http.StatusRequestEntityTooLarge)
	return
}
```
не препятствует начать загрузку файла, превышающего это ограничение.

- **Код проверяет наличие содержимого только после загрузки.** Можно создавать бесконечное количество пустых файлов.
- **Нет проверки на дублирование файлов.**
- **Используется ioutil, хотя он устаревший.**
- **Нарушитель может бесконечно загружать файл. Нет проверки тайм-аутов.**
- **Нет очистки временных файлов при ошибке.** Если во время загрузки произойдет ошибка, файл все равно останется.


### Третий пункт

- **Жестко закодированный secretKey.** Опять же, лучше использовать Vault.
- **В функции validatePaymentSignature нет проверки для payload**, а вдруг он не может быть разбит на элементы ожидаемым путем.
```Go
if len(elements) != 2 {
    return false
}
```

- **В обеих функциях нет проверки входных данных, а также данные не нормализуются.**
- #### **Нет временной метки и соответственно ее проверки.** 
Из-за этого перехваченные payload и signature можно использовать неограниченное количество раз.
- **Неправильная обработка ошибок через консоль** (далее я не буду обращать на это внимание)

### Четвертый пункт

```Go
if !containsDigit {
	fmt.Println("Password must contain at least one digit")
}
```

- **Код не предотвращает использование пустого или некорректного пароля.** =>
```Go
if !containsDigit {
    http.Error(w, "Password must contain at least one digit.", http.StatusBadRequest)
    return
}
```

- **В коде не проверяется минимальная и максимальная длина пароля.**
- **Отсутствует валидация и нормализация входных данных.** (r.FormValue("new_pass"), r.FormValue("csrf_token"))
).MatchString(csrfToken) {
    http.Error(w, "Invalid CSRF token.", http.StatusBadRequest)
    return
}
```

что-то вроде этого.
- **CSRF-токен можно перебрать. Фунция validateCsrfToken() просто сравнивает значения.**
-  **Пароли вероятно хранятся в открытом виде, а не хэшируются.**
- **Лучше ограничить обработчик handleChangePassword POST запросами.**

### Пятый пункт

- **Код не накладывает нужных требований на пароли.** Единственное что есть, это то, что минимальная длина 3.
- 
```Go
// Вместо
if login == storedUser || pass == storedPwd

// Нужно писать
if login == storedUser && pass == storedPwd
```

-  **Переменные SYS_PASSWORD и SYS_USERNAME используются в открытом виде.**
- **user_id и user_pass нужно экранировать**, чтобы избежать недобросовестного ввода.
- Authorize не проверяет метод запроса, что позволяет отправлять учетные данные через GET.
```Go
// Нужно так
if r.Method != http.MethodPost {
    http.Error(w, "Invalid request method", http.StatusMethodNotAllowed)
    return
}
```

- **Код проверяет, но не останавливает выполнение.**
```Go
if storedPwd == "" || storedUser == "" {
	fmt.Println("Environment variables not set")
}
```


### Шестой пункт

- **processPayment стоит ограничить только Post запросами.**
  ```Go
  if r.Method != http.MethodPost {
    http.Error(w, "Invalid request method", http.StatusMethodNotAllowed)
    return
}
```

- **item следовало бы проверять не только на длину и пустоту, но и на вредоносные последовательности/спец. символы**
- 
```Go
// Код выводит сообщение об ошибке, но продолжает выполнение функции
if !hasSufficientFunds(item) {
	http.Error(w, "Insufficient funds.", http.StatusForbidden)
}
// Нужно
if !hasSufficientFunds(item) {
    http.Error(w, "Insufficient funds.", http.StatusForbidden)
    return
}
```

- **Я бы уточнил, действительно ли так должна работать функция, что она не останавливает выполнение. Возможно так и нужно, глядя на контекст.**
```Go
if item == "free_item" {
	fmt.Println("Free item detected, no payment required")
}
```

- **Отсутствие ограничений на частоту запросов**
- **Отсутствие проверки и обработки ошибок из initiateOrder**. Какой-то сбой может оставить заказ в подвешенном состоянии.

### Седьмой пункт

- **get_picture стоит ограничить только GET запросами.**
```Go
if r.Method != http.MethodGet {
    http.Error(w, "Invalid request method", http.StatusMethodNotAllowed)
    return
}
```

- **file - это пользовательский ввод. И он никак не обрабатывается.** Это дает большое пространство для маневра нарушителя.
- **input не объявляется**
- **Функция checkIPInBlackList проверяет только имя хоста из предоставленного URL.** Если нарушитель передаст IP c символами или в необычном формате, то это поможет обойти проверку.
- **file тоже не определена.**
- **На сервере можно открыть любой файл, проверки нет.**
- Если os.Open(file) возвращает ошибку, вызов defer fd.Close(), будет некорректным, из-за того, что fd будет равен nil.


### Восьмой пункт

###### В приложении реализована 2FA, какие вектора атак вы будете тестировать, и к чему это может привести?

1. Сперва бы я проверил есть ли возможность войти по одному фактору. Проверил бы сбрасывается ли сессия 2FA при восстановлении пароля. Если да, и на руках есть сопутствующие данные, то считай у меня есть доступ.
2. При невозможности 1 пункта, я бы попробовал перехватить токен (вдруг слабое шифрование). Это так же даёт доступ к аккаунту.
3. Проверил бы надежность хранения QR.
4. Если используется push, то если есть возможность посмотрел бы на какое устройство оно отправляется. Вероятно я не смогу воспользоваться этой информацией.
5. Можно попробовать прислать себе код, и ввести его на другом аккаунте. Возможно это достаточно простая система 2FA, которая отправляет одинаковые коды в одно и то же время.
6. Проверил бы количество попыток ввода токена и пытался его брутфорсить.
7. Если ограничено время, а не количество попыток, я бы пытался успеть подобрать код в сессии.
8. Если ограничено кол-во попыток, но код не меняется при повторном запросе (в определенном промежутке), то снова брутфорс.
9.  Сменил бы IP, возможно это даст снова какое-то количество попыток.
10. Если есть функция "Запомнить меня", можно подобрать IP из white-list
11. Проверил бы можно ли с помощью фишинга выманить код (в данном случае, почти уверен, будет коррелировать то, насколько просто человеку передать код). Например код из 3 цифр - легко, QR - сложнее, сгенерированный ключ - сложно)
12. Если ничего не работает, я бы пытался временно/навсегда заблокировать доступ к аккаунту.


### Девятый пункт

1. Изменить amount (увеличить сумму перевода). https://wb.ru/send_money?from_id=123&to=456&amount=5000&sign=asdjhfashfkjashfkasf
2. Изменить to (на свой счет). https://wb.ru/send_money?from_id=123&to=567&amount=5000&sign=asdjhfashfkjashfkasf
3. Попытаться провести транзакцию от другого человека. https://wb.ru/send_money?from_id=234&to=567&amount=5000&sign=asdjhfashfkjashfkasf
4. Если sign не валидируется корректно можно сгенерировать собственный URL. Проверим как сервер реагирует на пустые подписи, подписи со спец символами.
5. Если подпись основана на статическом ключе, можно попытаться его восстановить.
6. Можно пробовать повторные переводы.
7. В URL можно встроить SQL-инъекцию и проверить реакцию сервера, если он не защищен можно это использовать почти в любых целях.
8. Убираем букву s в https и пытаемся устроить MitM.
9. Если сервер не проверяет CSRF можно с помощью фишинговых форм заставлять пользователя переводить деньги.

Последствиями почти всегда является несанкционированные переводы или нарушения работы сервера.

### Десятый пункт

- **Можно попытаться изменить PIN-код от имени пользователя.** Это можно сделать в том случае, если X-CSRF-Token не валидируется или отсутствует его серверная проверка.
- **Если 5643 это ID пользователя, то можно менять его, изменяя Пин для любых пользователей.**
- **Если пин-код хранится в бд без экранирования и проверки требуемых параметров, можно в пинкод встроить SQL-код**.
```Bash
pin_code=1231; DROP TABLE users;
```
- **Можно вводить странные значения Пин, например, 0, оставить пустым, -1234, очень длинное**
- **Даже если сейчас Пин другой, можно попробовать заново отправить аналогичный запрос.**
- **Можно пытаться подобрать пин брут-форсом**
- 
```Bash
pin_code=<script>alert('XSS')</script>
```
- 
```Bash
X-CSRF-Token: <script>alert('XSS')</script>
Cookie: <script>alert('XSS')</script>
```



## Заключительное задание

